   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"timer2.c"
  21              	.Ltext0:
  22              		.file 1 "../timer2.c"
 1880              		.align	2
 1881              		.global	timer2_ISR
 1883              	timer2_ISR:
 1884              	.LFB0:
   1:../timer2.c   **** /*********************************************************************************************
   2:../timer2.c   **** * Fichero:		timer2.c
   3:../timer2.c   **** * Autores:		Yasmina Albero e Iván Escuín
   4:../timer2.c   **** * Descrip:		funciones de control del timer2 del s3c44b0x
   5:../timer2.c   **** * Version: 1.0
   6:../timer2.c   **** *********************************************************************************************/
   7:../timer2.c   **** 
   8:../timer2.c   **** /*--- ficheros de cabecera ---*/
   9:../timer2.c   **** #include "timer2.h"
  10:../timer2.c   **** #include "44b.h"
  11:../timer2.c   **** #include "44blib.h"
  12:../timer2.c   **** 
  13:../timer2.c   **** /*--- variables globales ---*/
  14:../timer2.c   **** volatile unsigned int timer2_num_int;
  15:../timer2.c   **** 
  16:../timer2.c   **** /* declaración de función que es rutina de servicio de interrupción
  17:../timer2.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
  18:../timer2.c   **** void timer2_ISR(void) __attribute__((interrupt("IRQ")));
  19:../timer2.c   **** 
  20:../timer2.c   **** /*--- codigo de las funciones ---*/
  21:../timer2.c   **** /* Rutina de servicio de interrupción para timer2 */
  22:../timer2.c   **** void timer2_ISR(void)
  23:../timer2.c   **** {
 1885              		.loc 1 23 0
 1886              		.cfi_startproc
 1887              		@ Interrupt Service Routine.
 1888              		@ args = 0, pretend = 0, frame = 0
 1889              		@ frame_needed = 1, uses_anonymous_args = 0
 1890 0000 04C02DE5 		str	ip, [sp, #-4]!
 1891 0004 0DC0A0E1 		mov	ip, sp
 1892              	.LCFI0:
 1893              		.cfi_def_cfa_register 12
 1894 0008 0CD82DE9 		stmfd	sp!, {r2, r3, fp, ip, lr, pc}
 1895 000c 04B04CE2 		sub	fp, ip, #4
 1896              		.cfi_offset 14, -8
 1897              		.cfi_offset 13, -12
 1898              		.cfi_offset 11, -16
 1899              		.cfi_offset 3, -20
 1900              		.cfi_offset 2, -24
 1901              	.LCFI1:
 1902              		.cfi_def_cfa 11, 4
  24:../timer2.c   **** 	timer2_num_int++;
 1903              		.loc 1 24 0
 1904 0010 30309FE5 		ldr	r3, .L2
 1905 0014 003093E5 		ldr	r3, [r3, #0]
 1906 0018 012083E2 		add	r2, r3, #1
 1907 001c 24309FE5 		ldr	r3, .L2
 1908 0020 002083E5 		str	r2, [r3, #0]
  25:../timer2.c   **** 
  26:../timer2.c   **** 	/* borrar bit en I_ISPC para desactivar la solicitud de interrupción*/
  27:../timer2.c   **** 	rI_ISPC |= BIT_TIMER2; // BIT_TIMER2 está definido en 44b.h y pone un uno en el bit 11 que correpo
 1909              		.loc 1 27 0
 1910 0024 20309FE5 		ldr	r3, .L2+4
 1911 0028 1C209FE5 		ldr	r2, .L2+4
 1912 002c 002092E5 		ldr	r2, [r2, #0]
 1913 0030 022B82E3 		orr	r2, r2, #2048
 1914 0034 002083E5 		str	r2, [r3, #0]
  28:../timer2.c   **** }
 1915              		.loc 1 28 0
 1916 0038 14D04BE2 		sub	sp, fp, #20
 1917 003c 0C689DE8 		ldmfd	sp, {r2, r3, fp, sp, lr}
 1918 0040 04C09DE4 		ldmfd	sp!, {ip}
 1919 0044 04F05EE2 		subs	pc, lr, #4
 1920              	.L3:
 1921              		.align	2
 1922              	.L2:
 1923 0048 00000000 		.word	timer2_num_int
 1924 004c 2400E001 		.word	31457316
 1925              		.cfi_endproc
 1926              	.LFE0:
 1928              		.align	2
 1929              		.global	timer2_inicializar
 1931              	timer2_inicializar:
 1932              	.LFB1:
  29:../timer2.c   **** 
  30:../timer2.c   **** /* Función que inicializa el timer2, dejandolo listo para empezar la cuenta con timer2_empezar() */
  31:../timer2.c   **** void timer2_inicializar(void)
  32:../timer2.c   **** {
 1933              		.loc 1 32 0
 1934              		.cfi_startproc
 1935              		@ Function supports interworking.
 1936              		@ args = 0, pretend = 0, frame = 0
 1937              		@ frame_needed = 1, uses_anonymous_args = 0
 1938 0050 0DC0A0E1 		mov	ip, sp
 1939              	.LCFI2:
 1940              		.cfi_def_cfa_register 12
 1941 0054 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1942 0058 04B04CE2 		sub	fp, ip, #4
 1943              		.cfi_offset 14, -8
 1944              		.cfi_offset 13, -12
 1945              		.cfi_offset 11, -16
 1946              	.LCFI3:
 1947              		.cfi_def_cfa 11, 4
  33:../timer2.c   **** #ifndef EMU
  34:../timer2.c   **** 	/* Configuraion controlador de interrupciones */
  35:../timer2.c   **** 	rINTMOD = 0x0; // Configura las linas como de tipo IRQ
 1948              		.loc 1 35 0
 1949 005c 9C309FE5 		ldr	r3, .L5
 1950 0060 0020A0E3 		mov	r2, #0
 1951 0064 002083E5 		str	r2, [r3, #0]
  36:../timer2.c   **** 	rINTCON = 0x1; // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 1952              		.loc 1 36 0
 1953 0068 1E36A0E3 		mov	r3, #31457280
 1954 006c 0120A0E3 		mov	r2, #1
 1955 0070 002083E5 		str	r2, [r3, #0]
  37:../timer2.c   **** 	rINTMSK &= ~(BIT_TIMER2); // habilitamos en vector de mascaras de interrupcion el Timer2 (bits 26 
 1956              		.loc 1 37 0
 1957 0074 88309FE5 		ldr	r3, .L5+4
 1958 0078 84209FE5 		ldr	r2, .L5+4
 1959 007c 002092E5 		ldr	r2, [r2, #0]
 1960 0080 022BC2E3 		bic	r2, r2, #2048
 1961 0084 002083E5 		str	r2, [r3, #0]
  38:../timer2.c   **** 
  39:../timer2.c   **** 	/* Establece la rutina de servicio para TIMER2 */
  40:../timer2.c   **** 	pISR_TIMER2 = (unsigned) timer2_ISR;
 1962              		.loc 1 40 0
 1963 0088 78309FE5 		ldr	r3, .L5+8
 1964 008c 78209FE5 		ldr	r2, .L5+12
 1965 0090 002083E5 		str	r2, [r3, #0]
  41:../timer2.c   **** 
  42:../timer2.c   **** 	/* Configura el Timer2 */
  43:../timer2.c   **** 	rTCFG0 = rTCFG0 & 0xffff00ff; // Preescalado del timer2 en bits [15:8] de TCFG0. Dividimos entre 1
 1966              		.loc 1 43 0
 1967 0094 74309FE5 		ldr	r3, .L5+16
 1968 0098 70209FE5 		ldr	r2, .L5+16
 1969 009c 002092E5 		ldr	r2, [r2, #0]
 1970 00a0 FF2CC2E3 		bic	r2, r2, #65280
 1971 00a4 002083E5 		str	r2, [r3, #0]
  44:../timer2.c   **** 
  45:../timer2.c   **** 	/*****************************************
  46:../timer2.c   **** 	 * Bits de seleccion del MUX timer 2:	 *
  47:../timer2.c   **** 	 * 1/2 -> 0000	1/4-> 0001				 *
  48:../timer2.c   **** 	 * 1/8 -> 0010	1/16-> 0011	1/32 -> 0100 *
  49:../timer2.c   **** 	 *****************************************/
  50:../timer2.c   **** 	rTCFG1 = rTCFG1 & 0xfffff0ff; // Selección del mux para el divisor de frecuencia, bits [11:8] para
 1972              		.loc 1 50 0
 1973 00a8 64309FE5 		ldr	r3, .L5+20
 1974 00ac 60209FE5 		ldr	r2, .L5+20
 1975 00b0 002092E5 		ldr	r2, [r2, #0]
 1976 00b4 0F2CC2E3 		bic	r2, r2, #3840
 1977 00b8 002083E5 		str	r2, [r3, #0]
  51:../timer2.c   **** 	rTCNTB2 = 65535;// valor inicial de cuenta (la cuenta es descendente)
 1978              		.loc 1 51 0
 1979 00bc 54309FE5 		ldr	r3, .L5+24
 1980 00c0 54209FE5 		ldr	r2, .L5+28
 1981 00c4 002083E5 		str	r2, [r3, #0]
  52:../timer2.c   **** 	rTCMPB2 = 0 ;// valor de comparación (valor original 12800)
 1982              		.loc 1 52 0
 1983 00c8 50309FE5 		ldr	r3, .L5+32
 1984 00cc 0020A0E3 		mov	r2, #0
 1985 00d0 002083E5 		str	r2, [r3, #0]
  53:../timer2.c   **** 	//Timer control register, para timer2 bits [15:12] -> [15] auto-reload, [14] output inverter, [13]
  54:../timer2.c   **** 	/* establecer update=manual (bit 13), inverter=off (0 en bit 14)*/
  55:../timer2.c   **** 	rTCON = 0x00000000;
 1986              		.loc 1 55 0
 1987 00d4 48309FE5 		ldr	r3, .L5+36
 1988 00d8 0020A0E3 		mov	r2, #0
 1989 00dc 002083E5 		str	r2, [r3, #0]
  56:../timer2.c   **** 	rTCON |= 0x00002000;
 1990              		.loc 1 56 0
 1991 00e0 3C309FE5 		ldr	r3, .L5+36
 1992 00e4 38209FE5 		ldr	r2, .L5+36
 1993 00e8 002092E5 		ldr	r2, [r2, #0]
 1994 00ec 022A82E3 		orr	r2, r2, #8192
 1995 00f0 002083E5 		str	r2, [r3, #0]
  57:../timer2.c   **** #endif
  58:../timer2.c   **** }
 1996              		.loc 1 58 0
 1997 00f4 0CD04BE2 		sub	sp, fp, #12
 1998 00f8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1999 00fc 1EFF2FE1 		bx	lr
 2000              	.L6:
 2001              		.align	2
 2002              	.L5:
 2003 0100 0800E001 		.word	31457288
 2004 0104 0C00E001 		.word	31457292
 2005 0108 4CFF7F0C 		.word	209715020
 2006 010c 00000000 		.word	timer2_ISR
 2007 0110 0000D501 		.word	30736384
 2008 0114 0400D501 		.word	30736388
 2009 0118 2400D501 		.word	30736420
 2010 011c FFFF0000 		.word	65535
 2011 0120 2800D501 		.word	30736424
 2012 0124 0800D501 		.word	30736392
 2013              		.cfi_endproc
 2014              	.LFE1:
 2016              		.align	2
 2017              		.global	timer2_empezar
 2019              	timer2_empezar:
 2020              	.LFB2:
  59:../timer2.c   **** 
  60:../timer2.c   **** /* Funcion que inicia la cuenta mediante timer2*/
  61:../timer2.c   **** void timer2_empezar(void)
  62:../timer2.c   **** {
 2021              		.loc 1 62 0
 2022              		.cfi_startproc
 2023              		@ Function supports interworking.
 2024              		@ args = 0, pretend = 0, frame = 0
 2025              		@ frame_needed = 1, uses_anonymous_args = 0
 2026 0128 0DC0A0E1 		mov	ip, sp
 2027              	.LCFI4:
 2028              		.cfi_def_cfa_register 12
 2029 012c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2030 0130 04B04CE2 		sub	fp, ip, #4
 2031              		.cfi_offset 14, -8
 2032              		.cfi_offset 13, -12
 2033              		.cfi_offset 11, -16
 2034              	.LCFI5:
 2035              		.cfi_def_cfa 11, 4
  63:../timer2.c   **** #ifndef EMU
  64:../timer2.c   **** 	// Reiniciar variable contador
  65:../timer2.c   **** 	timer2_num_int=0;
 2036              		.loc 1 65 0
 2037 0134 30309FE5 		ldr	r3, .L8
 2038 0138 0020A0E3 		mov	r2, #0
 2039 013c 002083E5 		str	r2, [r3, #0]
  66:../timer2.c   **** 	//Reiniciar registro intermedio
  67:../timer2.c   **** 	rTCNTO2 = 0;
 2040              		.loc 1 67 0
 2041 0140 28309FE5 		ldr	r3, .L8+4
 2042 0144 0020A0E3 		mov	r2, #0
 2043 0148 002083E5 		str	r2, [r3, #0]
  68:../timer2.c   **** 	/* iniciar timer2 (bit 12) y auto-reload (bit 15)*/
  69:../timer2.c   **** 	rTCON ^= 0x0000B000;
 2044              		.loc 1 69 0
 2045 014c 20309FE5 		ldr	r3, .L8+8
 2046 0150 1C209FE5 		ldr	r2, .L8+8
 2047 0154 002092E5 		ldr	r2, [r2, #0]
 2048 0158 0B2A22E2 		eor	r2, r2, #45056
 2049 015c 002083E5 		str	r2, [r3, #0]
  70:../timer2.c   **** #endif
  71:../timer2.c   **** }
 2050              		.loc 1 71 0
 2051 0160 0CD04BE2 		sub	sp, fp, #12
 2052 0164 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2053 0168 1EFF2FE1 		bx	lr
 2054              	.L9:
 2055              		.align	2
 2056              	.L8:
 2057 016c 00000000 		.word	timer2_num_int
 2058 0170 2C00D501 		.word	30736428
 2059 0174 0800D501 		.word	30736392
 2060              		.cfi_endproc
 2061              	.LFE2:
 2063              		.global	__aeabi_ui2d
 2064              		.global	__aeabi_dmul
 2065              		.global	__aeabi_dadd
 2066              		.global	__aeabi_d2uiz
 2067              		.align	2
 2068              		.global	timer2_leer
 2070              	timer2_leer:
 2071              	.LFB3:
  72:../timer2.c   **** /* Funcion que obtiene el tiempo en microsegundos que se ha contado mediante el timer2.
  73:../timer2.c   ****  * Para obtener el tiempo sumaremos las veces que se ha realizado la resta con la fraccion de resta
  74:../timer2.c   ****  * que queda en el momento de leer. Este resultado le dividiremos la frecuencia de reloj en Mhz par
  75:../timer2.c   ****  * microsegundos. En este caso la frecuencia es 64Mhz y le aplicamos un divisor 1/2, con lo que ten
  76:../timer2.c   ****  * que dividir entre 32.
  77:../timer2.c   ****  */
  78:../timer2.c   **** unsigned int timer2_leer()
  79:../timer2.c   **** {
 2072              		.loc 1 79 0
 2073              		.cfi_startproc
 2074              		@ Function supports interworking.
 2075              		@ args = 0, pretend = 0, frame = 0
 2076              		@ frame_needed = 1, uses_anonymous_args = 0
 2077 0178 0DC0A0E1 		mov	ip, sp
 2078              	.LCFI6:
 2079              		.cfi_def_cfa_register 12
 2080 017c 78D82DE9 		stmfd	sp!, {r3, r4, r5, r6, fp, ip, lr, pc}
 2081 0180 04B04CE2 		sub	fp, ip, #4
 2082              		.cfi_offset 14, -8
 2083              		.cfi_offset 13, -12
 2084              		.cfi_offset 11, -16
 2085              		.cfi_offset 6, -20
 2086              		.cfi_offset 5, -24
 2087              		.cfi_offset 4, -28
 2088              		.cfi_offset 3, -32
 2089              	.LCFI7:
 2090              		.cfi_def_cfa 11, 4
  80:../timer2.c   **** #ifndef EMU
  81:../timer2.c   **** 	return timer2_num_int * (rTCNTB2 * 0.03125)	//Cuentas completas
 2091              		.loc 1 81 0
 2092 0184 EC309FE5 		ldr	r3, .L11
 2093 0188 003093E5 		ldr	r3, [r3, #0]
 2094 018c 0300A0E1 		mov	r0, r3
 2095 0190 FEFFFFEB 		bl	__aeabi_ui2d
 2096 0194 0050A0E1 		mov	r5, r0
 2097 0198 0160A0E1 		mov	r6, r1
 2098 019c D8309FE5 		ldr	r3, .L11+4
 2099 01a0 003093E5 		ldr	r3, [r3, #0]
 2100 01a4 0300A0E1 		mov	r0, r3
 2101 01a8 FEFFFFEB 		bl	__aeabi_ui2d
 2102 01ac 0030A0E1 		mov	r3, r0
 2103 01b0 0140A0E1 		mov	r4, r1
 2104 01b4 0300A0E1 		mov	r0, r3
 2105 01b8 0410A0E1 		mov	r1, r4
 2106 01bc 0020A0E3 		mov	r2, #0
 2107 01c0 FE35A0E3 		mov	r3, #1065353216
 2108 01c4 023683E2 		add	r3, r3, #2097152
 2109 01c8 FEFFFFEB 		bl	__aeabi_dmul
 2110 01cc 0030A0E1 		mov	r3, r0
 2111 01d0 0140A0E1 		mov	r4, r1
 2112 01d4 0500A0E1 		mov	r0, r5
 2113 01d8 0610A0E1 		mov	r1, r6
 2114 01dc 0320A0E1 		mov	r2, r3
 2115 01e0 0430A0E1 		mov	r3, r4
 2116 01e4 FEFFFFEB 		bl	__aeabi_dmul
 2117 01e8 0030A0E1 		mov	r3, r0
 2118 01ec 0140A0E1 		mov	r4, r1
 2119 01f0 0350A0E1 		mov	r5, r3
 2120 01f4 0460A0E1 		mov	r6, r4
  82:../timer2.c   **** 	        + ((rTCNTB2 - rTCNTO2) * 0.03125);	//Cuenta en el momento de lectura
 2121              		.loc 1 82 0
 2122 01f8 7C309FE5 		ldr	r3, .L11+4
 2123 01fc 002093E5 		ldr	r2, [r3, #0]
 2124 0200 78309FE5 		ldr	r3, .L11+8
 2125 0204 003093E5 		ldr	r3, [r3, #0]
 2126 0208 023063E0 		rsb	r3, r3, r2
 2127 020c 0300A0E1 		mov	r0, r3
 2128 0210 FEFFFFEB 		bl	__aeabi_ui2d
 2129 0214 0030A0E1 		mov	r3, r0
 2130 0218 0140A0E1 		mov	r4, r1
 2131 021c 0300A0E1 		mov	r0, r3
 2132 0220 0410A0E1 		mov	r1, r4
 2133 0224 0020A0E3 		mov	r2, #0
 2134 0228 FE35A0E3 		mov	r3, #1065353216
 2135 022c 023683E2 		add	r3, r3, #2097152
 2136 0230 FEFFFFEB 		bl	__aeabi_dmul
 2137 0234 0030A0E1 		mov	r3, r0
 2138 0238 0140A0E1 		mov	r4, r1
 2139 023c 0500A0E1 		mov	r0, r5
 2140 0240 0610A0E1 		mov	r1, r6
 2141 0244 0320A0E1 		mov	r2, r3
 2142 0248 0430A0E1 		mov	r3, r4
 2143 024c FEFFFFEB 		bl	__aeabi_dadd
 2144 0250 0030A0E1 		mov	r3, r0
 2145 0254 0140A0E1 		mov	r4, r1
  81:../timer2.c   **** 	return timer2_num_int * (rTCNTB2 * 0.03125)	//Cuentas completas
 2146              		.loc 1 81 0
 2147 0258 0300A0E1 		mov	r0, r3
 2148 025c 0410A0E1 		mov	r1, r4
 2149 0260 FEFFFFEB 		bl	__aeabi_d2uiz
 2150 0264 0030A0E1 		mov	r3, r0
  83:../timer2.c   **** #else
  84:../timer2.c   **** 	timer2_num_int++;
  85:../timer2.c   **** 	retrun timer2_num_int;
  86:../timer2.c   **** #endif
  87:../timer2.c   **** }
 2151              		.loc 1 87 0
 2152 0268 0300A0E1 		mov	r0, r3
 2153 026c 1CD04BE2 		sub	sp, fp, #28
 2154 0270 78689DE8 		ldmfd	sp, {r3, r4, r5, r6, fp, sp, lr}
 2155 0274 1EFF2FE1 		bx	lr
 2156              	.L12:
 2157              		.align	2
 2158              	.L11:
 2159 0278 00000000 		.word	timer2_num_int
 2160 027c 2400D501 		.word	30736420
 2161 0280 2C00D501 		.word	30736428
 2162              		.cfi_endproc
 2163              	.LFE3:
 2165              		.align	2
 2166              		.global	timer2_parar
 2168              	timer2_parar:
 2169              	.LFB4:
  88:../timer2.c   **** 
  89:../timer2.c   **** /* Funcion que para el timer y devuelve el tiempo transcurrido, pero no lo reinicia*/
  90:../timer2.c   **** unsigned int timer2_parar(void)
  91:../timer2.c   **** {
 2170              		.loc 1 91 0
 2171              		.cfi_startproc
 2172              		@ Function supports interworking.
 2173              		@ args = 0, pretend = 0, frame = 0
 2174              		@ frame_needed = 1, uses_anonymous_args = 0
 2175 0284 0DC0A0E1 		mov	ip, sp
 2176              	.LCFI8:
 2177              		.cfi_def_cfa_register 12
 2178 0288 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2179 028c 04B04CE2 		sub	fp, ip, #4
 2180              		.cfi_offset 14, -8
 2181              		.cfi_offset 13, -12
 2182              		.cfi_offset 11, -16
 2183              	.LCFI9:
 2184              		.cfi_def_cfa 11, 4
  92:../timer2.c   **** #ifndef EMU
  93:../timer2.c   **** 	/*parar timer2, desactivamos bit 12 en TCON*/
  94:../timer2.c   **** 	rTCON = rTCON & 0xffffEfff;
 2185              		.loc 1 94 0
 2186 0290 24309FE5 		ldr	r3, .L14
 2187 0294 20209FE5 		ldr	r2, .L14
 2188 0298 002092E5 		ldr	r2, [r2, #0]
 2189 029c 012AC2E3 		bic	r2, r2, #4096
 2190 02a0 002083E5 		str	r2, [r3, #0]
  95:../timer2.c   **** 	return timer2_leer();
 2191              		.loc 1 95 0
 2192 02a4 FEFFFFEB 		bl	timer2_leer
 2193 02a8 0030A0E1 		mov	r3, r0
  96:../timer2.c   **** #endif
  97:../timer2.c   **** }
 2194              		.loc 1 97 0
 2195 02ac 0300A0E1 		mov	r0, r3
 2196 02b0 0CD04BE2 		sub	sp, fp, #12
 2197 02b4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2198 02b8 1EFF2FE1 		bx	lr
 2199              	.L15:
 2200              		.align	2
 2201              	.L14:
 2202 02bc 0800D501 		.word	30736392
 2203              		.cfi_endproc
 2204              	.LFE4:
 2206              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timer2.c
                            *COM*:00000004 timer2_num_int
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:1880   .text:00000000 $a
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:1883   .text:00000000 timer2_ISR
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:1923   .text:00000048 $d
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:1928   .text:00000050 $a
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:1931   .text:00000050 timer2_inicializar
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2003   .text:00000100 $d
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2016   .text:00000128 $a
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2019   .text:00000128 timer2_empezar
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2057   .text:0000016c $d
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2067   .text:00000178 $a
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2070   .text:00000178 timer2_leer
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2159   .text:00000278 $d
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2165   .text:00000284 $a
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2168   .text:00000284 timer2_parar
C:\Users\Ivo\AppData\Local\Temp\ccMkqBod.s:2202   .text:000002bc $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_ui2d
__aeabi_dmul
__aeabi_dadd
__aeabi_d2uiz
