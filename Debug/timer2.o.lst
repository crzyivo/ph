   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"timer2.c"
  21              	.Ltext0:
  22              		.file 1 "../timer2.c"
 1880              		.align	2
 1881              		.global	timer2_ISR
 1883              	timer2_ISR:
 1884              	.LFB0:
   1:../timer2.c   **** /*********************************************************************************************
   2:../timer2.c   **** * Fichero:		timer2.c
   3:../timer2.c   **** * Autores:		Yasmina Albero e Iván Escuín
   4:../timer2.c   **** * Descrip:		funciones de control del timer2 del s3c44b0x
   5:../timer2.c   **** * Version: 1.0
   6:../timer2.c   **** *********************************************************************************************/
   7:../timer2.c   **** 
   8:../timer2.c   **** /*--- ficheros de cabecera ---*/
   9:../timer2.c   **** #include "timer2.h"
  10:../timer2.c   **** #include "44b.h"
  11:../timer2.c   **** #include "44blib.h"
  12:../timer2.c   **** 
  13:../timer2.c   **** /*--- variables globales ---*/
  14:../timer2.c   **** volatile unsigned int timer2_num_int;
  15:../timer2.c   **** 
  16:../timer2.c   **** /* declaración de función que es rutina de servicio de interrupción
  17:../timer2.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
  18:../timer2.c   **** void timer2_ISR(void) __attribute__((interrupt("IRQ")));
  19:../timer2.c   **** 
  20:../timer2.c   **** /*--- codigo de las funciones ---*/
  21:../timer2.c   **** /* Rutina de servicio de interrupción para timer2 */
  22:../timer2.c   **** void timer2_ISR(void)
  23:../timer2.c   **** {
 1885              		.loc 1 23 0
 1886              		.cfi_startproc
 1887              		@ Interrupt Service Routine.
 1888              		@ args = 0, pretend = 0, frame = 0
 1889              		@ frame_needed = 1, uses_anonymous_args = 0
 1890 0000 04C02DE5 		str	ip, [sp, #-4]!
 1891 0004 0DC0A0E1 		mov	ip, sp
 1892              	.LCFI0:
 1893              		.cfi_def_cfa_register 12
 1894 0008 0CD82DE9 		stmfd	sp!, {r2, r3, fp, ip, lr, pc}
 1895 000c 04B04CE2 		sub	fp, ip, #4
 1896              		.cfi_offset 14, -8
 1897              		.cfi_offset 13, -12
 1898              		.cfi_offset 11, -16
 1899              		.cfi_offset 3, -20
 1900              		.cfi_offset 2, -24
 1901              	.LCFI1:
 1902              		.cfi_def_cfa 11, 4
  24:../timer2.c   **** 	timer2_num_int++;
 1903              		.loc 1 24 0
 1904 0010 30309FE5 		ldr	r3, .L2
 1905 0014 003093E5 		ldr	r3, [r3, #0]
 1906 0018 012083E2 		add	r2, r3, #1
 1907 001c 24309FE5 		ldr	r3, .L2
 1908 0020 002083E5 		str	r2, [r3, #0]
  25:../timer2.c   **** 
  26:../timer2.c   **** 	/* borrar bit en I_ISPC para desactivar la solicitud de interrupción*/
  27:../timer2.c   **** 	rI_ISPC |= BIT_TIMER2; // BIT_TIMER2 está definido en 44b.h y pone un uno en el bit 11 que correpo
 1909              		.loc 1 27 0
 1910 0024 20309FE5 		ldr	r3, .L2+4
 1911 0028 1C209FE5 		ldr	r2, .L2+4
 1912 002c 002092E5 		ldr	r2, [r2, #0]
 1913 0030 022B82E3 		orr	r2, r2, #2048
 1914 0034 002083E5 		str	r2, [r3, #0]
  28:../timer2.c   **** }
 1915              		.loc 1 28 0
 1916 0038 14D04BE2 		sub	sp, fp, #20
 1917 003c 0C689DE8 		ldmfd	sp, {r2, r3, fp, sp, lr}
 1918 0040 04C09DE4 		ldmfd	sp!, {ip}
 1919 0044 04F05EE2 		subs	pc, lr, #4
 1920              	.L3:
 1921              		.align	2
 1922              	.L2:
 1923 0048 00000000 		.word	timer2_num_int
 1924 004c 2400E001 		.word	31457316
 1925              		.cfi_endproc
 1926              	.LFE0:
 1928              		.align	2
 1929              		.global	timer2_inicializar
 1931              	timer2_inicializar:
 1932              	.LFB1:
  29:../timer2.c   **** 
  30:../timer2.c   **** /* Función que inicializa el timer2, dejandolo listo para empezar la cuenta con timer2_empezar() */
  31:../timer2.c   **** void timer2_inicializar(void)
  32:../timer2.c   **** {
 1933              		.loc 1 32 0
 1934              		.cfi_startproc
 1935              		@ Function supports interworking.
 1936              		@ args = 0, pretend = 0, frame = 0
 1937              		@ frame_needed = 1, uses_anonymous_args = 0
 1938 0050 0DC0A0E1 		mov	ip, sp
 1939              	.LCFI2:
 1940              		.cfi_def_cfa_register 12
 1941 0054 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1942 0058 04B04CE2 		sub	fp, ip, #4
 1943              		.cfi_offset 14, -8
 1944              		.cfi_offset 13, -12
 1945              		.cfi_offset 11, -16
 1946              	.LCFI3:
 1947              		.cfi_def_cfa 11, 4
  33:../timer2.c   **** #ifndef EMU
  34:../timer2.c   **** 	/* Configuraion controlador de interrupciones */
  35:../timer2.c   **** 	rINTMOD = 0x0; // Configura las linas como de tipo IRQ
 1948              		.loc 1 35 0
 1949 005c 94309FE5 		ldr	r3, .L5
 1950 0060 0020A0E3 		mov	r2, #0
 1951 0064 002083E5 		str	r2, [r3, #0]
  36:../timer2.c   **** 	rINTCON = 0x1; // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 1952              		.loc 1 36 0
 1953 0068 1E36A0E3 		mov	r3, #31457280
 1954 006c 0120A0E3 		mov	r2, #1
 1955 0070 002083E5 		str	r2, [r3, #0]
  37:../timer2.c   **** 	rINTMSK &= ~(BIT_TIMER2); // habilitamos en vector de mascaras de interrupcion el Timer2 (bits 26 
 1956              		.loc 1 37 0
 1957 0074 80309FE5 		ldr	r3, .L5+4
 1958 0078 7C209FE5 		ldr	r2, .L5+4
 1959 007c 002092E5 		ldr	r2, [r2, #0]
 1960 0080 022BC2E3 		bic	r2, r2, #2048
 1961 0084 002083E5 		str	r2, [r3, #0]
  38:../timer2.c   **** 
  39:../timer2.c   **** 	/* Establece la rutina de servicio para TIMER2 */
  40:../timer2.c   **** 	pISR_TIMER2 = (unsigned) timer2_ISR;
 1962              		.loc 1 40 0
 1963 0088 70309FE5 		ldr	r3, .L5+8
 1964 008c 70209FE5 		ldr	r2, .L5+12
 1965 0090 002083E5 		str	r2, [r3, #0]
  41:../timer2.c   **** 
  42:../timer2.c   **** 	/* Configura el Timer2 */
  43:../timer2.c   **** 	rTCFG0 = rTCFG0 & 0xffff00ff; // Preescalado del timer2 en bits [15:8] de TCFG0. Dividimos entre 1
 1966              		.loc 1 43 0
 1967 0094 6C309FE5 		ldr	r3, .L5+16
 1968 0098 68209FE5 		ldr	r2, .L5+16
 1969 009c 002092E5 		ldr	r2, [r2, #0]
 1970 00a0 FF2CC2E3 		bic	r2, r2, #65280
 1971 00a4 002083E5 		str	r2, [r3, #0]
  44:../timer2.c   **** 
  45:../timer2.c   **** 	/*****************************************
  46:../timer2.c   **** 	 * Bits de seleccion del MUX timer 2:	 *
  47:../timer2.c   **** 	 * 1/2 -> 0000	1/4-> 0001				 *
  48:../timer2.c   **** 	 * 1/8 -> 0010	1/16-> 0011	1/32 -> 0100 *
  49:../timer2.c   **** 	 *****************************************/
  50:../timer2.c   **** 	rTCFG1 = rTCFG1 & 0xfffff0ff; // Selección del mux para el divisor de frecuencia, bits [11:8] para
 1972              		.loc 1 50 0
 1973 00a8 5C309FE5 		ldr	r3, .L5+20
 1974 00ac 58209FE5 		ldr	r2, .L5+20
 1975 00b0 002092E5 		ldr	r2, [r2, #0]
 1976 00b4 0F2CC2E3 		bic	r2, r2, #3840
 1977 00b8 002083E5 		str	r2, [r3, #0]
  51:../timer2.c   **** 	rTCNTB2 = 65535;// valor inicial de cuenta (la cuenta es descendente)
 1978              		.loc 1 51 0
 1979 00bc 4C309FE5 		ldr	r3, .L5+24
 1980 00c0 4C209FE5 		ldr	r2, .L5+28
 1981 00c4 002083E5 		str	r2, [r3, #0]
  52:../timer2.c   **** 	rTCMPB2 = 0 ;// valor de comparación (valor original 12800)
 1982              		.loc 1 52 0
 1983 00c8 48309FE5 		ldr	r3, .L5+32
 1984 00cc 0020A0E3 		mov	r2, #0
 1985 00d0 002083E5 		str	r2, [r3, #0]
  53:../timer2.c   **** 	//Timer control register, para timer2 bits [15:12] -> [15] auto-reload, [14] output inverter, [13]
  54:../timer2.c   **** 	/* establecer update=manual (bit 13), inverter=off (0 en bit 14)*/
  55:../timer2.c   **** 	rTCON = (rTCON & 0xffff0fff) | 0x00002000;
 1986              		.loc 1 55 0
 1987 00d4 40309FE5 		ldr	r3, .L5+36
 1988 00d8 3C209FE5 		ldr	r2, .L5+36
 1989 00dc 002092E5 		ldr	r2, [r2, #0]
 1990 00e0 0F2AC2E3 		bic	r2, r2, #61440
 1991 00e4 022A82E3 		orr	r2, r2, #8192
 1992 00e8 002083E5 		str	r2, [r3, #0]
  56:../timer2.c   **** #endif
  57:../timer2.c   **** }
 1993              		.loc 1 57 0
 1994 00ec 0CD04BE2 		sub	sp, fp, #12
 1995 00f0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1996 00f4 1EFF2FE1 		bx	lr
 1997              	.L6:
 1998              		.align	2
 1999              	.L5:
 2000 00f8 0800E001 		.word	31457288
 2001 00fc 0C00E001 		.word	31457292
 2002 0100 4CFF7F0C 		.word	209715020
 2003 0104 00000000 		.word	timer2_ISR
 2004 0108 0000D501 		.word	30736384
 2005 010c 0400D501 		.word	30736388
 2006 0110 2400D501 		.word	30736420
 2007 0114 FFFF0000 		.word	65535
 2008 0118 2800D501 		.word	30736424
 2009 011c 0800D501 		.word	30736392
 2010              		.cfi_endproc
 2011              	.LFE1:
 2013              		.align	2
 2014              		.global	timer2_empezar
 2016              	timer2_empezar:
 2017              	.LFB2:
  58:../timer2.c   **** 
  59:../timer2.c   **** /* Funcion que inicia la cuenta mediante timer2*/
  60:../timer2.c   **** void timer2_empezar(void)
  61:../timer2.c   **** {
 2018              		.loc 1 61 0
 2019              		.cfi_startproc
 2020              		@ Function supports interworking.
 2021              		@ args = 0, pretend = 0, frame = 0
 2022              		@ frame_needed = 1, uses_anonymous_args = 0
 2023 0120 0DC0A0E1 		mov	ip, sp
 2024              	.LCFI4:
 2025              		.cfi_def_cfa_register 12
 2026 0124 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2027 0128 04B04CE2 		sub	fp, ip, #4
 2028              		.cfi_offset 14, -8
 2029              		.cfi_offset 13, -12
 2030              		.cfi_offset 11, -16
 2031              	.LCFI5:
 2032              		.cfi_def_cfa 11, 4
  62:../timer2.c   **** #ifndef EMU
  63:../timer2.c   **** 	// Reiniciar variable contador
  64:../timer2.c   **** 	timer2_num_int=0;
 2033              		.loc 1 64 0
 2034 012c 30309FE5 		ldr	r3, .L8
 2035 0130 0020A0E3 		mov	r2, #0
 2036 0134 002083E5 		str	r2, [r3, #0]
  65:../timer2.c   **** 	//Reiniciar registro intermedio
  66:../timer2.c   **** 	rTCNTO2 = 0;
 2037              		.loc 1 66 0
 2038 0138 28309FE5 		ldr	r3, .L8+4
 2039 013c 0020A0E3 		mov	r2, #0
 2040 0140 002083E5 		str	r2, [r3, #0]
  67:../timer2.c   **** 	/* iniciar timer2 (bit 12) y auto-reload (bit 15)*/
  68:../timer2.c   **** 	rTCON ^= 0x0000B000;
 2041              		.loc 1 68 0
 2042 0144 20309FE5 		ldr	r3, .L8+8
 2043 0148 1C209FE5 		ldr	r2, .L8+8
 2044 014c 002092E5 		ldr	r2, [r2, #0]
 2045 0150 0B2A22E2 		eor	r2, r2, #45056
 2046 0154 002083E5 		str	r2, [r3, #0]
  69:../timer2.c   **** #endif
  70:../timer2.c   **** }
 2047              		.loc 1 70 0
 2048 0158 0CD04BE2 		sub	sp, fp, #12
 2049 015c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2050 0160 1EFF2FE1 		bx	lr
 2051              	.L9:
 2052              		.align	2
 2053              	.L8:
 2054 0164 00000000 		.word	timer2_num_int
 2055 0168 2C00D501 		.word	30736428
 2056 016c 0800D501 		.word	30736392
 2057              		.cfi_endproc
 2058              	.LFE2:
 2060              		.global	__aeabi_ui2d
 2061              		.global	__aeabi_dmul
 2062              		.global	__aeabi_dadd
 2063              		.global	__aeabi_d2uiz
 2064              		.align	2
 2065              		.global	timer2_leer
 2067              	timer2_leer:
 2068              	.LFB3:
  71:../timer2.c   **** /* Funcion que obtiene el tiempo en microsegundos que se ha contado mediante el timer2.
  72:../timer2.c   ****  * Para obtener el tiempo sumaremos las veces que se ha realizado la resta con la fraccion de resta
  73:../timer2.c   ****  * que queda en el momento de leer. Este resultado le dividiremos la frecuencia de reloj en Mhz par
  74:../timer2.c   ****  * microsegundos. En este caso la frecuencia es 64Mhz y le aplicamos un divisor 1/2, con lo que ten
  75:../timer2.c   ****  * que dividir entre 32.
  76:../timer2.c   ****  */
  77:../timer2.c   **** unsigned int timer2_leer()
  78:../timer2.c   **** {
 2069              		.loc 1 78 0
 2070              		.cfi_startproc
 2071              		@ Function supports interworking.
 2072              		@ args = 0, pretend = 0, frame = 0
 2073              		@ frame_needed = 1, uses_anonymous_args = 0
 2074 0170 0DC0A0E1 		mov	ip, sp
 2075              	.LCFI6:
 2076              		.cfi_def_cfa_register 12
 2077 0174 78D82DE9 		stmfd	sp!, {r3, r4, r5, r6, fp, ip, lr, pc}
 2078 0178 04B04CE2 		sub	fp, ip, #4
 2079              		.cfi_offset 14, -8
 2080              		.cfi_offset 13, -12
 2081              		.cfi_offset 11, -16
 2082              		.cfi_offset 6, -20
 2083              		.cfi_offset 5, -24
 2084              		.cfi_offset 4, -28
 2085              		.cfi_offset 3, -32
 2086              	.LCFI7:
 2087              		.cfi_def_cfa 11, 4
  79:../timer2.c   **** #ifndef EMU
  80:../timer2.c   **** 	return timer2_num_int * (rTCNTB2 * 0.03125)	//Cuentas completas
 2088              		.loc 1 80 0
 2089 017c EC309FE5 		ldr	r3, .L11
 2090 0180 003093E5 		ldr	r3, [r3, #0]
 2091 0184 0300A0E1 		mov	r0, r3
 2092 0188 FEFFFFEB 		bl	__aeabi_ui2d
 2093 018c 0050A0E1 		mov	r5, r0
 2094 0190 0160A0E1 		mov	r6, r1
 2095 0194 D8309FE5 		ldr	r3, .L11+4
 2096 0198 003093E5 		ldr	r3, [r3, #0]
 2097 019c 0300A0E1 		mov	r0, r3
 2098 01a0 FEFFFFEB 		bl	__aeabi_ui2d
 2099 01a4 0030A0E1 		mov	r3, r0
 2100 01a8 0140A0E1 		mov	r4, r1
 2101 01ac 0300A0E1 		mov	r0, r3
 2102 01b0 0410A0E1 		mov	r1, r4
 2103 01b4 0020A0E3 		mov	r2, #0
 2104 01b8 FE35A0E3 		mov	r3, #1065353216
 2105 01bc 023683E2 		add	r3, r3, #2097152
 2106 01c0 FEFFFFEB 		bl	__aeabi_dmul
 2107 01c4 0030A0E1 		mov	r3, r0
 2108 01c8 0140A0E1 		mov	r4, r1
 2109 01cc 0500A0E1 		mov	r0, r5
 2110 01d0 0610A0E1 		mov	r1, r6
 2111 01d4 0320A0E1 		mov	r2, r3
 2112 01d8 0430A0E1 		mov	r3, r4
 2113 01dc FEFFFFEB 		bl	__aeabi_dmul
 2114 01e0 0030A0E1 		mov	r3, r0
 2115 01e4 0140A0E1 		mov	r4, r1
 2116 01e8 0350A0E1 		mov	r5, r3
 2117 01ec 0460A0E1 		mov	r6, r4
  81:../timer2.c   **** 	        + ((rTCNTB2 - rTCNTO2) * 0.03125);	//Cuenta en el momento de lectura
 2118              		.loc 1 81 0
 2119 01f0 7C309FE5 		ldr	r3, .L11+4
 2120 01f4 002093E5 		ldr	r2, [r3, #0]
 2121 01f8 78309FE5 		ldr	r3, .L11+8
 2122 01fc 003093E5 		ldr	r3, [r3, #0]
 2123 0200 023063E0 		rsb	r3, r3, r2
 2124 0204 0300A0E1 		mov	r0, r3
 2125 0208 FEFFFFEB 		bl	__aeabi_ui2d
 2126 020c 0030A0E1 		mov	r3, r0
 2127 0210 0140A0E1 		mov	r4, r1
 2128 0214 0300A0E1 		mov	r0, r3
 2129 0218 0410A0E1 		mov	r1, r4
 2130 021c 0020A0E3 		mov	r2, #0
 2131 0220 FE35A0E3 		mov	r3, #1065353216
 2132 0224 023683E2 		add	r3, r3, #2097152
 2133 0228 FEFFFFEB 		bl	__aeabi_dmul
 2134 022c 0030A0E1 		mov	r3, r0
 2135 0230 0140A0E1 		mov	r4, r1
 2136 0234 0500A0E1 		mov	r0, r5
 2137 0238 0610A0E1 		mov	r1, r6
 2138 023c 0320A0E1 		mov	r2, r3
 2139 0240 0430A0E1 		mov	r3, r4
 2140 0244 FEFFFFEB 		bl	__aeabi_dadd
 2141 0248 0030A0E1 		mov	r3, r0
 2142 024c 0140A0E1 		mov	r4, r1
  80:../timer2.c   **** 	return timer2_num_int * (rTCNTB2 * 0.03125)	//Cuentas completas
 2143              		.loc 1 80 0
 2144 0250 0300A0E1 		mov	r0, r3
 2145 0254 0410A0E1 		mov	r1, r4
 2146 0258 FEFFFFEB 		bl	__aeabi_d2uiz
 2147 025c 0030A0E1 		mov	r3, r0
  82:../timer2.c   **** #else
  83:../timer2.c   **** 	timer2_num_int++;
  84:../timer2.c   **** 	retrun timer2_num_int;
  85:../timer2.c   **** #endif
  86:../timer2.c   **** }
 2148              		.loc 1 86 0
 2149 0260 0300A0E1 		mov	r0, r3
 2150 0264 1CD04BE2 		sub	sp, fp, #28
 2151 0268 78689DE8 		ldmfd	sp, {r3, r4, r5, r6, fp, sp, lr}
 2152 026c 1EFF2FE1 		bx	lr
 2153              	.L12:
 2154              		.align	2
 2155              	.L11:
 2156 0270 00000000 		.word	timer2_num_int
 2157 0274 2400D501 		.word	30736420
 2158 0278 2C00D501 		.word	30736428
 2159              		.cfi_endproc
 2160              	.LFE3:
 2162              		.align	2
 2163              		.global	timer2_parar
 2165              	timer2_parar:
 2166              	.LFB4:
  87:../timer2.c   **** 
  88:../timer2.c   **** /* Funcion que para el timer y devuelve el tiempo transcurrido, pero no lo reinicia*/
  89:../timer2.c   **** unsigned int timer2_parar(void)
  90:../timer2.c   **** {
 2167              		.loc 1 90 0
 2168              		.cfi_startproc
 2169              		@ Function supports interworking.
 2170              		@ args = 0, pretend = 0, frame = 0
 2171              		@ frame_needed = 1, uses_anonymous_args = 0
 2172 027c 0DC0A0E1 		mov	ip, sp
 2173              	.LCFI8:
 2174              		.cfi_def_cfa_register 12
 2175 0280 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2176 0284 04B04CE2 		sub	fp, ip, #4
 2177              		.cfi_offset 14, -8
 2178              		.cfi_offset 13, -12
 2179              		.cfi_offset 11, -16
 2180              	.LCFI9:
 2181              		.cfi_def_cfa 11, 4
  91:../timer2.c   **** #ifndef EMU
  92:../timer2.c   **** 	/*parar timer2, desactivamos bit 12 en TCON*/
  93:../timer2.c   **** 	rTCON = rTCON & 0xffffEfff;
 2182              		.loc 1 93 0
 2183 0288 24309FE5 		ldr	r3, .L14
 2184 028c 20209FE5 		ldr	r2, .L14
 2185 0290 002092E5 		ldr	r2, [r2, #0]
 2186 0294 012AC2E3 		bic	r2, r2, #4096
 2187 0298 002083E5 		str	r2, [r3, #0]
  94:../timer2.c   **** 	return timer2_leer();
 2188              		.loc 1 94 0
 2189 029c FEFFFFEB 		bl	timer2_leer
 2190 02a0 0030A0E1 		mov	r3, r0
  95:../timer2.c   **** #endif
  96:../timer2.c   **** }
 2191              		.loc 1 96 0
 2192 02a4 0300A0E1 		mov	r0, r3
 2193 02a8 0CD04BE2 		sub	sp, fp, #12
 2194 02ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2195 02b0 1EFF2FE1 		bx	lr
 2196              	.L15:
 2197              		.align	2
 2198              	.L14:
 2199 02b4 0800D501 		.word	30736392
 2200              		.cfi_endproc
 2201              	.LFE4:
 2203              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timer2.c
                            *COM*:00000004 timer2_num_int
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:1880   .text:00000000 $a
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:1883   .text:00000000 timer2_ISR
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:1923   .text:00000048 $d
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:1928   .text:00000050 $a
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:1931   .text:00000050 timer2_inicializar
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2000   .text:000000f8 $d
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2013   .text:00000120 $a
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2016   .text:00000120 timer2_empezar
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2054   .text:00000164 $d
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2064   .text:00000170 $a
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2067   .text:00000170 timer2_leer
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2156   .text:00000270 $d
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2162   .text:0000027c $a
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2165   .text:0000027c timer2_parar
C:\Users\Ivo\AppData\Local\Temp\ccHtgFHd.s:2199   .text:000002b4 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_ui2d
__aeabi_dmul
__aeabi_dadd
__aeabi_d2uiz
